@* Menu - The customer menu and order viewer. *@

@* Import the model definitions. *@
@using PickUpOrder.Models

@* The menu is always in this format to start. *@
@model IQueryable<MenuItem>

@* Define variables used by the rest of the page. *@
@{
    ViewBag.Title = "Menu";
    var db = new PickUpOrderDBEntities2();
    var removals = new Dictionary<MenuItem, int>();

    // Sort by category, then convert to a list to ease iteration.
    var menuContent = Model.OrderBy(e => e.Category).ToList();

    // Get the current user cookie and use that to get their order list.
    var curUser = db.Accounts.Find(int.Parse(Request.Cookies["UserID"].Value));

    // Get the account's most recent order if it exists.
    // If there isn't one or it is submitted, add a new one.
    var mostRecentOrder = db.Orders.Find(curUser.MostRecentOrder());
    if (mostRecentOrder == null ||
        mostRecentOrder.OrderStatus != (int) OrderStatus.NotSubmitted)
    {
        curUser.AddNewOrder();
        db.SaveChanges();
        mostRecentOrder = db.Orders.Find(curUser.MostRecentOrder());
    }
    var allOrders = curUser.OrdersToList();
}

<p>Orders: @curUser.Orders</p>

@* Print the header. *@
<h2>Welcome to the menu.</h2>
@Html.ActionLink("Refresh/Exit Search", "Menu", "Menu")

@* Search function. *@
@using (Html.BeginForm("Search", "Menu", FormMethod.Post))
{
    @* This is the query box. *@
    @Html.TextBox("query")

    @* This is the dropdown list containing all categories. *@
    @Html.DropDownList("category", Category.GetCategoryDropdown(),
                       "Filter by category...")
    <input type="submit" value="Search" />
}

@* Display every item in the menu in their respective category. *@
@for (int i = 0; i < menuContent.Count; i++)
{
    @* A category is only null if an item is deleted, so skip if it's null. *@
    if (menuContent[i].Category == null)
    { continue; }
    @* Print the category name. *@
    <h3>@db.Categories.Find(menuContent[i].Category).CategoryName</h3>
    <table>
        @* Print the table header. *@
        <thread>
            <tr>
                <td>Name</td>
                <td>Price</td>
            </tr>
        </thread>
        @for (; i < menuContent.Count; i++)
        {
            @* No need to check whether an item is valid.
                Invalid items were pushed to the start of the list
                since they had null categories. *@
            <tr>
                <td>@menuContent[i].Name</td>
                <td>
                    $@(((int)menuContent[i].Price / 100.0).ToString("0.00"))
                </td>
                <td>
                    @Html.ActionLink("Add to Order", "AddToOrder", "Menu",
                                     new { IDtoAdd = menuContent[i].ItemID },
                                     null)
                </td>
            </tr>
            <tr>
                <td colspan="3">@menuContent[i].Description</td>
            </tr>

            @* If this is the end of a category, exit this loop
                to print the next category header. *@
            if (i != menuContent.Count - 1 &&
                menuContent[i].Category != menuContent[i + 1].Category)
            { break; }
        }
    </table>
}

@* If there is an order associated with the user, display it. *@
@if (mostRecentOrder != null && mostRecentOrder.ContentsToItemList() != null)
{
    <h2>Order details</h2>
    @* Print the contents string. *@
    @* FIXME: Remove once testing begins. *@
    <h2>Contents: @mostRecentOrder.OrderContents</h2>
    <table>
        @foreach (MenuItem item in mostRecentOrder.ContentsToItemList())
        {
            @* If the item should be removed, then add it to the chopping block. *@
            if (item.Price == null && removals.ContainsKey(item))
            { removals[item]++; }
            else if (item.Price == null)
            { removals.Add(item, 1); }

            @* Otherwise, print its information. *@
            else
            {
                <tr>
                    <td>@item.Name</td>
                    <td>$@(((int)item.Price / 100.0).ToString("0.00"))</td>
                    <td>
                        @Html.ActionLink("Remove", "RemoveFromOrder", "Menu",
                                          new { IDtoRemove = item.ItemID }, null)
                    </td>
                </tr>
            }
        }
    </table>

    @* If something is removable, remove it and let the user know. *@
    if (removals.Count >= 1)
    {
        foreach (MenuItem toRemove in removals.Keys)
        { mostRecentOrder.RemoveMultipleItems(toRemove, removals[toRemove]); }
        db.SaveChanges();

        @* Print the correct message depending on the number of removals. *@
        if (removals.Count == 1)
        { 
            <p>
                An item was removed from your order
                because it was deleted from the menu.
            </p>
        }
        else
        {
            <p>
                @removals.Count items were removed from your order
                because they were deleted from the menu.
            </p>
        }
    }
    <h2>Total cost: $@mostRecentOrder.CalcFinalCost()</h2>
}

<div/>

@* Once users are implemented, provide the status of submitted orders here. *@
@* Since the last one will always be the current order, look at all others. *@
@if (allOrders.Count - 1 > 0)
{
    <h2>Submitted orders:</h2>
    <table>
        <tr>
            <td>Order #</td>
            <td>Contents</td>
            <td>Status</td>
        </tr>
        @for (int i = 0; i < allOrders.Count - 1; i++)
        {
            var contents = allOrders[i].ContentsToItemList();
            <tr>
                <td>@allOrders[i].OrderID</td>
                <td> 
                    @contents[0].Name
                    @for (int j = 1; j < contents.Count; j++)
                    {
                        <br>@contents[j].Name
                    }
                </td>
                <td>@((OrderStatus) allOrders[i].OrderStatus)</td>
            </tr>
        }
    </table>
}

@* Define the cell size. *@
<style type="text/css">
    td {
        width: 200px;
    }
</style>